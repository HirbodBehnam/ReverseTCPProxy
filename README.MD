# Reverse TCP Proxy

A port forwarder which the server sends the SYN packet to client.

## What?

A simple TCP port forwarder usually works by creating an outgoing connection to destination server for each incoming
local connection. In nutshell, a program in client connects to port forwarder client, port forwarder client connects to
severs, server establishes the connection between itself and client and then creates a connection to another host.
Now the traffic between the initializer and last host is proxied between port forwarder client and server.

The thing you have to note here is that the client will initiate the connection between itself and server. On some
cases, you may want the server to start the connection with the client. Obviously this requires a client which is
exposed to internet, either by port forwarding or by not having NAT at all.

### How the fuck?

Next question is how does the server connect to the client if client is the one which shall make the connections and
knows when it does need another stream? The answer: _WE CHEAT_

We don't want to make direct connection to our server right? But it's fine for a CDN (like cloudflare) to make
connection with our server. So the server program also listens for HTTP requests on another port and upon receiving a
specific request, it will initiate a connection with the client.

Each connection has an ID which it's generated by the client. They serve no purpose other than logging. When client asks
for a connection, it also specifies an ID and in the first packet of server to client the ID is given to client.

### Life cycle of a TCP connection

We have two programs: `jailed` and `freedom`. `jailed` is our client and `freedom` is our server.

1. A program starts a TCP connection with `jailed`.
2. Jailed creates a random ID and sends it via a simple POST request to `freedom` via a CDN like cloudflare. Note
   that `jailed` is not establishing a connection to `freedom`; CDN is making it!
3. `freedom` establishes a connection with `jailed`. The ID is given in the first packet. The first packet is obfuscated
   as a simple HTTP request.
4. While this connection is being established, `freedom` also establishes a connection with remote host which packets
   should be forwarded to.
5. `jailed` does the handshake (parsing the first packet and extracting the ID). The connection is rejected if the
   handshake fails.
6. Now we have a stream between `jailed` and `freedom` which `freedom` started it.
7. A connection is closed on both ends upon either side closing it.

### Schematic

Schematic of the connection can be illustrated with the diagram below:

```
Local Service             Destination Host
     ↕                               ↕
  Jailed <------- Direct -------> Freedom
     ↧                               ↥
     ┕ ----------- CDN ------------- ┙ 
```

## Running

### Building

Before anything, you must have something to run! Before starting, make sure that you have Go 1.20. Then simply clone
this repo and execute following commands to build both `jailed` and `freedom`.

```bash
go build ./cmd/jailed/
go build ./cmd/freedom/
```

### Freedom

To run the `freedom` app, create a file called `config.json` next to it. The sample config file exists in the `examples`
directory. Here is the file:

```json
{
  "control_listen": "127.0.0.1:53141",
  "jailed_computer_address": "1.1.1.1:32521",
  "destination_address": "127.0.0.1:51109"
}
```

All of the keys are necessary and have the following meaning:

* `control_listen`: The address that the control messages (the ones relayed through the CDN) comes in.
* `jailed_computer_address`: The address which should be dialed to connect to the jailed PC.
* `destination_address`: Where packets should go after being proxied.

### Jailed

A sample config JSON file looks like this:

```json
{
  "local_listen_address": "127.0.0.1:24519",
  "freedom_listen_address": "0.0.0.0:32521",
  "control_endpoint": "https://my-domain.com/",
  "remote_wait_timeout": 5000
}
```

All keys except `remote_wait_timeout` are necessary.

* `local_listen_address`: On which interface and port connections are being accepted from the local service.
* `freedom_listen_address`: On which interface and port should we listen for direct connections from `freedom`.
* `control_endpoint`: What is the domain behind CDN which connects us to `control_listen` of `freedom`. (Hint: You might
  want to use a reverse proxy like Caddy or Nginx)
* `remote_wait_timeout`: How long should be waited before terminating a local connection because of the absence of
  remote connection. In other words, `freedom` has this much milliseconds to make a connection with `jailed` otherwise
  the connection is dropped. The unit of this option is milliseconds and the default value is 10 seconds.